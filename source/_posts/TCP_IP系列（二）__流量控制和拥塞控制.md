---
title: TCP流量控制和拥塞控制
date: 2019-04-20 12:52:34
tags:
    - TCP/IP
---
## 流量控制和拥塞控制的区别
假如你约了你胖友当面说一个事情，这时候大概又两种方式：

* 一次和你说一句话，然后等你说，收到啦，确认你在听之后，他再说一句，你再接着确认，直到把事情说完。
* 一次性和你把话说完，然后你再点点头确认你听到了。

理想的情况下，方式二应该是最好的，这样一来一回就够了，但是在实际过程中，你还需要考虑一些别的问题，比如：

* 对方的理解能力。一次说太多别人不一定能接受的过来。
* 聊天的环境，如果环境比较嘈杂，比如在KTV里，那你一次也不能说太多的话，否则你巴拉说一堆，你的胖友说，啊？你刚才说啥？就会很尴尬。

问题一就是流量控制（Flow control），考虑的是接收方的信息处理能力。
问题二就是拥塞控制（Congestion cntrol），考虑的是网络能容纳的信息的能力。

## 基本概念
* MSS：Maximum Segment Size，TCP一次传输发送的最大数据段长度。
* RTT：Round-Trip Time，往返时延，表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。
* 滑动窗口：滑动窗口是类似于一个窗口一样的东西，是用来告诉发送端可以发送数据的大小或者说是窗口标记了接收端缓冲区的大小，这样就可以实现一次批量的发送数据
* rwnd 接收端窗口 （也称为通知窗口）：接收端缓冲区大小，表示接收方的接收能力。接收端将此窗口值放在 TCP 报文的首部中的窗口字段，传送给发送端。
* cwnd 拥塞窗口：发送端缓冲区大小

## 流量控制
> TCP uses an end-to-end flow control protocol to avoid having the sender send data too fast for the TCP receiver to receive and process it reliably. Having a mechanism for flow control is essential in an environment where machines of diverse network speeds communicate.(TCP使用端到端流量控制协议来避免发送方发送数据太快，以致TCP接收方不能可靠地接收和处理数据。在不同网络速度的机器进行通信的环境中，具有流量控制机制至关重要。  

### 假如没有流量控制...

![](http://60.205.3.9/img/noFlowControl.jpg)

从图上可以看到，发送方一直在发送数据，如果接收方已经接收满了，那么接下来发送的数据将被丢弃。                                                                                

### 流量控制举例

![](http://60.205.3.9/img/flowControl.jpg)

由图中可知，TCP三次流量控制分别是，第一次窗口大小由4kb减到2kb，第二次减到1kb，第三次减到0。 

### 流量控制中的死锁问题

如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍为0，则重设持续计时器，继续等待。

### 发送数据的时机

#### 三种TCP传输机制

1. TCP维持一个变量，它等于最大报文段长度MSS。只要缓存中存放的数据达到了MSS字节时，就组装成一个TCP报文段发送出去。

2. 发送方的应用进程指明要求发送报文段，即TCP支持的推送（push）操作。

3. 发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不超过MSS）发送出去。

#### Nagle算法
>Nagle算法主要是避免发送小的数据包，要求TCP连接上最多只能有一个未被确认的小分组，在该分组的确认到达之前不能发送其他的小分组。相反，TCP收集这些少量的小分组，并在确认到来时以一个分组的方式发出去。

```
if there is new data to send
  if the window size >= MSS and available data is >= MSS
    send complete MSS segment now
  else
    if there is unconfirmed data still in the pipe
      enqueue data in the buffer until an acknowledge is received
    else
      send data immediately
    end if
  end if
end if
```

从上述代码可以看出：

1. 对于MSS的片段，直接发出
2. 如果有没有被确认的data在缓冲区内，先将待发送的数据放到buffer中直到被发送的数据被确认【最多只能有一个未被确认的小分组】
3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；

该算法的优越之处在于它是自适应的，确认到达的越快，数据也就发送的越快；而在希望减少微小分组数目的低速广域网上，则会发送更少的分组；

#### 延迟确认 Delayed Ack

tcp协议规定在接受到数据段时需要向对方发送一个确认,但如果只是单纯的发送一个确认,代价会比较高(20字节的ip首部,20字节的tcp首部),最好能附带响应数据一起发送给对方.所以tcp在何时发送ack给对方有以下规定:

1. 当有响应数据要发送时,ack会随响数据立即发送给对方.

2. 如果没有响应数据,ack的发送将会有一个延迟,以等待看是否有响应数据可以一起发送,这称是"Delayed Ack".但这个延迟最多不会超过500ms,一般为200ms.如果在200ms内有数据要发送,那么ack会随数据一起立即发送给对方.注意这里的延迟200ms,不是指的从接受到对方数据到发送ack的最长等待时间差.而是指的内核启动的一个定时器,它每隔200ms就查看下是否有ack要发送.例如:假设定时器在0ms时启动,对方的数据段在
185ms时到达,那么ack最迟会在200ms时发送,而不是385ms时发送.

3. 如果在等待发送ack期间,对方的第二个数据段又到达了,这时要立即发送ack.但是如果对方的三个数据段相继到达,那么第二个数据段到达时ack立即发送,但第三个数据段到达时是否立即发送,则取决于上面两条.

#### 糊涂窗口综合征

TCP接收方的缓存已满，而交互式的应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为1个字节（但发送的数据报为40字节的的话）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小。

## 拥塞（读 se）控制
>网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

先约定讨论的前提 ：
1. 数据是单方向传送，而另外一个方向只传送确认
2. 接收方总是有足够大的缓存空间，因为发送窗口的大小由网络的拥塞程度来决定。
3. 以TCP报文段的个数为讨论问题的单位，而不是以字节为单位。

### 拥塞控制的方法
1. 慢开始（Slow-start）、拥塞避免（Congestion Avoidance）
2. 快重传（Fast Restrangsmit）、快恢复（Fast Recovery）

### 拥塞控制的思路
 1. 当主机开始发送数据时，如果立即将较大的发送窗口的全部数据字节都注入到网络中，那么由于不清楚网络的情况，有可能引其网络拥塞
 2. 比较好的方法是试探一下，即从小到达逐渐增大发送端的拥塞控制窗口数值
 3. 通常在刚刚开始发送报文段时可先将拥塞窗口cwnd设置为一个最大报文段的MSS的数值。在每收到一个对新报文段确认后，将拥塞窗口增加至多一个MSS的数值，为了防止拥塞窗口cwind的增长引起网络拥塞，还需要另外一个变量---慢开始门限ssthresh
 
　　　　　　1）当cwnd < ssthresh时，使用慢开始算法

　　　　　　2）当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法

　　　　　　3）当cwnd = ssthresh时 即可以使用慢开始算法，也可以使用拥塞避免算法。

### 拥塞控制流程图
![](http://60.205.3.9/img/congestionControl.jpg)

### 慢开始

#### 慢开始流程图
![](http://60.205.3.9/img/slowStart.png)

1. 在一开始发送方先设置cwnd = 1，发送第一个报文段M1，接收方收到后确认M1

2. 发送方收到对M1的确认后，把cwnd从1增大到2，于是发送方接着发送M2和M3两个报文段，接收方收到后发回对M2和M3的确认

3. 发送方每收到一个对新报文段的确认（重传的不算在内）就使发送方的拥塞窗口加1，因此发送方在收到两个确认后，cwnd就从2增大到4，并可发送M4~M7共4个报文段

4. 使用慢开始算法后，每经过一个传输轮次，拥塞窗口cwnd就加倍。

### 拥塞避免

1. 假定cwnd等于10个MSS的长度，而MSS是1460字节，发送方可一连发送14600字节（即10个报文段）。

2. 假定接收方每收到一个报文段就发回一个确认。

3. 于是发送方每到一个新的确认，就把拥塞窗口稍微增大一些，即增大0.1 MSS = 146字节。

4. 经过一个往返时间RTT（或一个传输轮次）后，发送方共收到10个新的确认，拥塞窗口就增大了1460字节，正好是一个MSS的大小。）

5. 不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法增大”AI的特点。

6. 这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。

### 快重传 
#### 快重传思路

1. 让发送方尽早知道发生了个别报文段的丢失。

2. 快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。

#### 举例
![](http://60.205.3.9/img/FastRessemble.png)

1、接收方收到了M1和M2后都分别及时发出了确认。

2、现假定接收方没有收到M3的但收到了M4，本来接收方可以什么都不做。

3、但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3。

4、发送方接着发送M5和M6，接收方收到后也仍要再次分别发出对M2的重复确认。

5、这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。

6、快重传算法规定，发送方只要一收到3个重复确认，就知道接受方确实没有收到报文段M3，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会认为出现了网络拥塞。

### 快恢复
1. 当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半，这是为了预防网络发生拥塞。

2. 由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是把cwnd值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法，是拥塞窗口的线性增大。

## 实际流程中的拥塞控制

发送方窗口的上限值 = Min[rwnd， cwnd]，因为实际上接收方的缓存空间总是有限的。

## 参考资料
[https://www.cnblogs.com/iou123lg/p/9017044.html](https://www.cnblogs.com/iou123lg/p/9017044.html)

[https://blog.csdn.net/qq_38623623/article/details/81290265](https://blog.csdn.net/qq_38623623/article/details/81290265)

[https://blog.csdn.net/wdscq1234/article/details/52432095](https://blog.csdn.net/wdscq1234/article/details/52432095)

[https://www.cnblogs.com/kubidemanong/p/9987810.html](https://www.cnblogs.com/kubidemanong/p/9987810.html)

[http://www.it165.net/pro/html/201403/10465.html](http://www.it165.net/pro/html/201403/10465.html)