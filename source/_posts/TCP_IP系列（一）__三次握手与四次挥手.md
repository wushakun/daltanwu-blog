---
layout: TCP/IP协议
title: TCP三次握手和四次挥手的简单理解
date: 2019-04-18 21:16:24
tags:
    - TCP/IP
---
 
三次握手和四次挥手是TCP协议的基础，相信每个人都听过。TCP位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手和四次挥手策略。


## 三次握手
### 为什么需要三次握手？
>想象一下你想在微信上想找个胖友聊天，那么你会怎么开始呢？

* 先和他招呼
* 然后他给你一个回应

接下来你们就会开始聊天了。等等，不是说三次握手吗？这不两次就搞定了。

这里需要考虑一种异常的情况-----你和他打了招呼之后，他过了很久才回你的消息，这时候他不知道你是否还有聊天的欲望。

所以他必须等到你再次回应，你们才会开始聊天。所以三次握手是非常必要的。

### 三次握手流程图

![](http://60.205.3.9/img/ThreeHands.PNG)

### 三次握手流程详解

* 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

* 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

* 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

### 举例
		   TCP A                                                TCP B
		​
		  1.  CLOSED                                               LISTEN
		​
		  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED
		​
		  3.  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED
		​
		  4.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED
		​
		  5.  ESTABLISHED --> <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED
			
### 特殊情况

* 第一个包，即A发给B的SYN 中途被丢，没有到达B

	A会周期性超时重传，直到收到B的确认

* 第二个包，即B发给A的SYN +ACK 中途被丢，没有到达A

	B会周期性超时重传，直到收到A的确认

* 第三个包，即A发给B的ACK 中途被丢，没有到达B

	A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：

	a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接也为 Established状态，双向可以发包。

	b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。

	c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。
	
## 四次挥手
### 为什么需要四次挥手？

>想象一下你想和这位胖友结束聊天，那么你会怎么说呢？

* 你说我还有点事，不聊了
* 他回复，拜拜
* 你说OK~

然后就结束了。等等，不是说四次挥手吗？怎么三次就搞定了

这里需要考虑一种异常的情况-----对方正在输入中的时候，你突然告诉他你有事，不聊了，他肯定不答应，因为TCP是可靠的，不可能有话没说完的情况。

所以他会说，知道了，不过刚才还有话没说完，

然后开始说事，说完了再拜拜

然后你再回，知道了，拜拜。

当然，他也可能没有话要说了，所以有时候第二步的确认收到和第三步的拜拜也可能合并成一条数据 。

### 四次挥手流程图

![](http://60.205.3.9/img/FourBye.PNG)

### 流程详解

* 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
* 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
* 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
* 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
* 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
* 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

### 特殊情况（最后为啥要再等待2MSL？）

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。